import pytest
import sys
import json
import time
import sqlite3
import hashlib
from pathlib import Path

project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from fastapi.testclient import TestClient

class TestIdempotencyDetailed:
    @pytest.fixture(scope="class")
    def intake_client(self):
        """TestClient –¥–ª—è intake-api"""
        try:
            import os
            original_cwd = os.getcwd()
            intake_dir = project_root / "intake-api"
            os.chdir(intake_dir)
            
            if str(intake_dir) not in sys.path:
                sys.path.insert(0, str(intake_dir))
            
            modules_to_clear = [k for k in sys.modules.keys() if k.startswith('main') or k.startswith('routes')]
            for module in modules_to_clear:
                if module in sys.modules:
                    del sys.modules[module]
            
            import main as intake_main
            os.chdir(original_cwd)
            
            return TestClient(intake_main.app)
            
        except Exception as e:
            pytest.skip(f"Cannot create intake client: {e}")

    @pytest.fixture
    def db_connection(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
        db_path = project_root / "database.sqlite"
        if db_path.exists():
            conn = sqlite3.connect(str(db_path))
            yield conn
            conn.close()
        else:
            pytest.skip("Database not found")

    def _find_post_endpoint(self, client):
        """–ù–∞—Ö–æ–¥–∏–º —Ä–∞–±–æ—á–∏–π POST endpoint –¥–ª—è –ª–∏–¥–æ–≤"""
        try:
            openapi = client.get("/openapi.json").json()
            for path, methods in openapi.get('paths', {}).items():
                if 'post' in methods and 'lead' in path.lower():
                    return path
        except:
            pass
        
        test_endpoints = ["/leads", "/api/leads", "/v1/leads"]
        for endpoint in test_endpoints:
            try:
                response = client.post(endpoint, json={"note": "test"})
                if response.status_code != 404:
                    return endpoint
            except:
                continue
        return None

    def test_idempotency_same_request_no_duplication(self, intake_client, db_connection):
        """
        –¢–ï–°–¢ 2: –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        
        –ü–æ–≤—Ç–æ—Ä POST /leads —Å —Ç–µ–º –∂–µ Idempotency-Key –∏ —Ç–µ–º –∂–µ —Ç–µ–ª–æ–º –¥–æ–ª–∂–µ–Ω:
        1. –í–µ—Ä–Ω—É—Ç—å —Ç–æ—Ç –∂–µ –æ—Ç–≤–µ—Ç (200, –Ω–µ 201)
        2. –ù–ï —Å–æ–∑–¥–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç –ª–∏–¥–∞ –≤ –ë–î
        3. –ù–ï —Å–æ–∑–¥–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç —Å–æ–±—ã—Ç–∏—è –≤ –æ—á–µ—Ä–µ–¥–∏
        4. –í–µ—Ä–Ω—É—Ç—å —Ç–æ—á–Ω–æ —Ç–µ –∂–µ –¥–∞–Ω–Ω—ã–µ
        """
        print("\nüîÑ DETAILED TEST: Idempotency - No Data/Event Duplication")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        print(f"‚úÖ Using endpoint: {endpoint}")
        
        lead_data = {
            "email": "idempotency-test@example.com",
            "phone": "+1234567890",
            "name": "Idempotency Test User",
            "note": "Testing that duplicate requests don't create duplicate data",
            "source": "idempotency_detailed_test"
        }
        
        idempotency_key = f"detailed-test-{int(time.time())}"
        
        print(f"\nüìù STEP 1: Making first request...")
        print(f"   üìã Idempotency-Key: {idempotency_key}")
        print(f"   üìã Email: {lead_data['email']}")
        
        cursor = db_connection.cursor()
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data['email'],))
        leads_before = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data['source'],))
        source_leads_before = cursor.fetchone()[0]
        
        print(f"   üìä Leads with this email before: {leads_before}")
        print(f"   üìä Leads with this source before: {source_leads_before}")
        
        start_time_1 = time.time()
        response1 = intake_client.post(
            endpoint,
            json=lead_data,
            headers={"Idempotency-Key": idempotency_key}
        )
        end_time_1 = time.time()
        
        print(f"   üìã First response: {response1.status_code} (took {end_time_1 - start_time_1:.3f}s)")
        
        assert response1.status_code in [200, 201], f"First request failed: {response1.status_code}"
        
        lead1_data = response1.json()
        lead_id = lead1_data["id"]
        
        print(f"   ‚úÖ First lead created: {lead_id}")
        print(f"   üìã Response data: {json.dumps(lead1_data, indent=2)}")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data['email'],))
        leads_after_first = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data['source'],))
        source_leads_after_first = cursor.fetchone()[0]
        
        cursor.execute("SELECT * FROM leads WHERE id = ?", (lead_id,))
        db_lead = cursor.fetchone()
        
        print(f"   üìä Leads with this email after first: {leads_after_first}")
        print(f"   üìä Leads with this source after first: {source_leads_after_first}")
        print(f"   üìä Lead in DB: {db_lead}")
        
        assert leads_after_first == leads_before + 1, "Should create exactly one lead"
        assert source_leads_after_first == source_leads_before + 1, "Should create exactly one lead for this source"
        assert db_lead is not None, "Lead should exist in database"
        
        time.sleep(0.1)
        
        print(f"\nüîÑ STEP 2: Making identical second request...")
        print(f"   üìã Same Idempotency-Key: {idempotency_key}")
        print(f"   üìã Same payload: {lead_data['email']}")
        
        start_time_2 = time.time()
        response2 = intake_client.post(
            endpoint,
            json=lead_data,  
            headers={"Idempotency-Key": idempotency_key}  
        )
        end_time_2 = time.time()
        
        print(f"   üìã Second response: {response2.status_code} (took {end_time_2 - start_time_2:.3f}s)")
        
        assert response2.status_code == 200, f"Expected 200 for idempotent request, got {response2.status_code}"
        
        lead2_data = response2.json()
        
        print(f"   ‚úÖ Second response status: {response2.status_code} (idempotent)")
        print(f"   üìã Second response data: {json.dumps(lead2_data, indent=2)}")
        
        print(f"\nüîç STEP 3: Verifying response identity...")
        
        assert lead1_data["id"] == lead2_data["id"], f"Lead IDs must be identical: {lead1_data['id']} vs {lead2_data['id']}"
        assert lead1_data["email"] == lead2_data["email"], "Email must be identical"
        assert lead1_data["phone"] == lead2_data["phone"], "Phone must be identical"
        assert lead1_data["name"] == lead2_data["name"], "Name must be identical"
        assert lead1_data["note"] == lead2_data["note"], "Note must be identical"
        assert lead1_data["source"] == lead2_data["source"], "Source must be identical"
        assert lead1_data["created_at"] == lead2_data["created_at"], "Creation timestamp must be identical"
        
        print(f"   ‚úÖ All response fields are identical")
        
        print(f"\nüóÑÔ∏è  STEP 4: Verifying no database duplication...")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data['email'],))
        leads_after_second = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data['source'],))
        source_leads_after_second = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE id = ?", (lead_id,))
        lead_count = cursor.fetchone()[0]
        
        print(f"   üìä Leads with this email after second: {leads_after_second}")
        print(f"   üìä Leads with this source after second: {source_leads_after_second}")
        print(f"   üìä Leads with this ID: {lead_count}")
        
        assert leads_after_second == leads_after_first, f"No new leads should be created: {leads_after_second} vs {leads_after_first}"
        assert source_leads_after_second == source_leads_after_first, f"No new source leads should be created"
        assert lead_count == 1, f"Should have exactly one lead with this ID, got {lead_count}"
        
        print(f"   ‚úÖ No database duplication detected")
        
        cursor.execute("SELECT * FROM leads WHERE id = ?", (lead_id,))
        db_lead_after = cursor.fetchone()
        
        assert db_lead == db_lead_after, "Database record should not change"
        
        print(f"   ‚úÖ Database record unchanged")
        
        print(f"\nüéØ STEP 5: Checking event creation...")
        
        response_time_1 = end_time_1 - start_time_1
        response_time_2 = end_time_2 - start_time_2
        
        print(f"   üìä First request time: {response_time_1:.3f}s")
        print(f"   üìä Second request time: {response_time_2:.3f}s")
        
        if response_time_2 < response_time_1:
            print(f"   ‚úÖ Second request faster (likely cached)")
        else:
            print(f"   ‚ÑπÔ∏è  Response times similar")
        
        print(f"\nüéâ IDEMPOTENCY TEST PASSED!")
        print(f"   ‚úÖ Same response returned")
        print(f"   ‚úÖ No data duplication")
        print(f"   ‚úÖ No database changes")
        print(f"   ‚úÖ Proper status codes (201 ‚Üí 200)")
        
        return {
            "lead_id": lead_id,
            "first_response": lead1_data,
            "second_response": lead2_data,
            "response_times": {
                "first": response_time_1,
                "second": response_time_2
            }
        }

    def test_idempotency_multiple_calls(self, intake_client, db_connection):
        """
        –¢–µ—Å—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
        –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ 5+ –≤—ã–∑–æ–≤–æ–≤ —Å –æ–¥–Ω–∏–º –∫–ª—é—á–æ–º –Ω–µ —Å–æ–∑–¥–∞—é—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã
        """
        print("\nüîÑ TEST: Multiple Idempotent Calls")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        lead_data = {
            "email": "multiple-idempotency@example.com",
            "name": "Multiple Test User",
            "note": "Testing multiple idempotent calls",
            "source": "multiple_idempotency_test"
        }
        
        idempotency_key = f"multiple-{int(time.time())}"
        
        print(f"üìã Making 5 identical requests with key: {idempotency_key}")
        
        responses = []
        response_times = []
        
        cursor = db_connection.cursor()
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data['email'],))
        initial_count = cursor.fetchone()[0]
        
        for i in range(5):
            print(f"   üîµ Request {i+1}/5...")
            
            start_time = time.time()
            response = intake_client.post(
                endpoint,
                json=lead_data,
                headers={"Idempotency-Key": idempotency_key}
            )
            end_time = time.time()
            
            response_time = end_time - start_time
            responses.append(response)
            response_times.append(response_time)
            
            print(f"      Status: {response.status_code}, Time: {response_time:.3f}s")
            
            time.sleep(0.05)
        
        print(f"\nüìä Results Analysis:")
        
        assert responses[0].status_code == 201, f"First request should be 201, got {responses[0].status_code}"
        
        for i, response in enumerate(responses[1:], 2):
            assert response.status_code == 200, f"Request {i} should be 200, got {response.status_code}"
        
        print(f"   ‚úÖ Status codes correct: 201, 200, 200, 200, 200")
        
        lead_ids = [resp.json()["id"] for resp in responses]
        unique_ids = set(lead_ids)
        
        assert len(unique_ids) == 1, f"All responses should have same lead_id, got: {unique_ids}"
        
        lead_id = lead_ids[0]
        print(f"   ‚úÖ All responses have same lead_id: {lead_id}")
        
        first_data = responses[0].json()
        for i, response in enumerate(responses[1:], 2):
            response_data = response.json()
            assert response_data == first_data, f"Response {i} differs from first response"
        
        print(f"   ‚úÖ All response bodies are identical")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data['email'],))
        final_count = cursor.fetchone()[0]
        
        assert final_count == initial_count + 1, f"Should have exactly one new lead, got {final_count - initial_count}"
        
        print(f"   ‚úÖ Only one record created in database")
        
        avg_time = sum(response_times) / len(response_times)
        print(f"   üìä Average response time: {avg_time:.3f}s")
        print(f"   üìä Response times: {[f'{t:.3f}s' for t in response_times]}")
        
        print(f"üéâ MULTIPLE IDEMPOTENCY TEST PASSED!")

    def test_idempotency_edge_cases(self, intake_client, db_connection):
        """
        –¢–µ—Å—Ç –≥—Ä–∞–Ω–∏—á–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        """
        print("\nüéØ TEST: Idempotency Edge Cases")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        print("\n   üîç Case 1: Very long idempotency key")
        
        long_key = "very-long-idempotency-key-" + "x" * 200 + f"-{int(time.time())}"
        
        lead_data1 = {
            "email": "edge-case-1@example.com",
            "note": "Long idempotency key test",
            "source": "edge_case_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=lead_data1,
            headers={"Idempotency-Key": long_key}
        )
        
        response2 = intake_client.post(
            endpoint,
            json=lead_data1,
            headers={"Idempotency-Key": long_key}
        )
        
        assert response1.status_code == 201, "First long key request should succeed"
        assert response2.status_code == 200, "Second long key request should be idempotent"
        assert response1.json()["id"] == response2.json()["id"], "Should return same lead"
        
        print(f"      ‚úÖ Long idempotency key works")
        
        print("\n   üîç Case 2: Special characters in key")
        
        special_key = f"special-key-!@#$%^&*()_+-={int(time.time())}"
        
        lead_data2 = {
            "email": "edge-case-2@example.com",
            "note": "Special characters in key test",
            "source": "edge_case_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=lead_data2,
            headers={"Idempotency-Key": special_key}
        )
        
        response2 = intake_client.post(
            endpoint,
            json=lead_data2,
            headers={"Idempotency-Key": special_key}
        )
        
        assert response1.status_code == 201, "First special key request should succeed"
        assert response2.status_code == 200, "Second special key request should be idempotent"
        
        print(f"      ‚úÖ Special characters in key work")
        
        print("\n   üîç Case 3: Large payload")
        
        large_note = "Large payload test. " + "Lorem ipsum dolor sit amet. " * 100
        
        lead_data3 = {
            "email": "edge-case-3@example.com",
            "name": "Large Payload User",
            "note": large_note,
            "source": "edge_case_test"
        }
        
        large_key = f"large-payload-{int(time.time())}"
        
        response1 = intake_client.post(
            endpoint,
            json=lead_data3,
            headers={"Idempotency-Key": large_key}
        )
        
        response2 = intake_client.post(
            endpoint,
            json=lead_data3,
            headers={"Idempotency-Key": large_key}
        )
        
        assert response1.status_code == 201, "First large payload request should succeed"
        assert response2.status_code == 200, "Second large payload request should be idempotent"
        assert response1.json()["note"] == large_note, "Large note should be preserved"
        assert response1.json() == response2.json(), "Large payload responses should be identical"
        
        print(f"      ‚úÖ Large payload idempotency works")
        
        print(f"üéâ EDGE CASES TEST PASSED!")

    def test_idempotency_conflict_detailed(self, intake_client, db_connection):
        """
        –¢–ï–°–¢ 3: –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        
        –ü–æ–≤—Ç–æ—Ä POST /leads —Å —Ç–µ–º –∂–µ Idempotency-Key –Ω–æ –î–†–£–ì–ò–ú —Ç–µ–ª–æ–º –¥–æ–ª–∂–µ–Ω:
        1. –í–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É 409 (Conflict) –∏–ª–∏ 422 (Unprocessable Entity)
        2. –ù–ï —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ª–∏–¥ –≤ –ë–î
        3. –ù–ï –∏–∑–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ª–∏–¥
        4. –í–µ—Ä–Ω—É—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
        """
        print("\n‚ö†Ô∏è  DETAILED TEST: Idempotency Conflict - Different Body")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        print(f"‚úÖ Using endpoint: {endpoint}")
        
        idempotency_key = f"conflict-test-{int(time.time())}"
        
        lead_data_1 = {
            "email": "conflict-original@example.com",
            "phone": "+1111111111",
            "name": "Original User",
            "note": "This is the original request content",
            "source": "conflict_test"
        }
        
        lead_data_2 = {
            "email": "conflict-different@example.com",  
            "phone": "+2222222222",                    
            "name": "Different User",                  
            "note": "This is completely different content", 
            "source": "conflict_test"                  
        }
        
        print(f"\nüìù STEP 1: Making first request...")
        print(f"   üìã Idempotency-Key: {idempotency_key}")
        print(f"   üìã First email: {lead_data_1['email']}")
        print(f"   üìã First name: {lead_data_1['name']}")
        
        cursor = db_connection.cursor()
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data_1['source'],))
        leads_before = cursor.fetchone()[0]
        
        print(f"   üìä Leads with source '{lead_data_1['source']}' before: {leads_before}")
        
        start_time_1 = time.time()
        response1 = intake_client.post(
            endpoint,
            json=lead_data_1,
            headers={"Idempotency-Key": idempotency_key}
        )
        end_time_1 = time.time()
        
        print(f"   üìã First response: {response1.status_code} (took {end_time_1 - start_time_1:.3f}s)")
        
        assert response1.status_code in [200, 201], f"First request failed: {response1.status_code}"
        
        lead1_data = response1.json()
        lead1_id = lead1_data["id"]
        
        print(f"   ‚úÖ First lead created: {lead1_id}")
        print(f"   üìã First response data: {json.dumps(lead1_data, indent=2)}")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data_1['source'],))
        leads_after_first = cursor.fetchone()[0]
        
        cursor.execute("SELECT * FROM leads WHERE id = ?", (lead1_id,))
        db_lead_original = cursor.fetchone()
        
        print(f"   üìä Leads after first request: {leads_after_first}")
        print(f"   üìä Original lead in DB: {db_lead_original}")
        
        assert leads_after_first == leads_before + 1, "Should create exactly one lead"
        assert db_lead_original is not None, "Lead should exist in database"
        
        time.sleep(0.1)
        
        print(f"\n‚ö†Ô∏è  STEP 2: Making conflicting second request...")
        print(f"   üìã Same Idempotency-Key: {idempotency_key}")
        print(f"   üìã Different email: {lead_data_2['email']}")
        print(f"   üìã Different name: {lead_data_2['name']}")
        print(f"   üìã Different content: This should cause conflict!")
        
        start_time_2 = time.time()
        response2 = intake_client.post(
            endpoint,
            json=lead_data_2,  
            headers={"Idempotency-Key": idempotency_key}  
        )
        end_time_2 = time.time()
        
        print(f"   üìã Second response: {response2.status_code} (took {end_time_2 - start_time_2:.3f}s)")
        print(f"   üìã Second response body: {response2.text}")
        
        print(f"\nüîç STEP 3: Verifying conflict detection...")
        
        assert response2.status_code in [409, 422], f"Expected 409/422 for conflict, got {response2.status_code}"
        
        print(f"   ‚úÖ Correct error status: {response2.status_code}")
        
        try:
            error_data = response2.json()
            print(f"   üìã Error response: {json.dumps(error_data, indent=2)}")
            
            error_text = str(error_data).lower()
            conflict_keywords = ["conflict", "idempotency", "duplicate", "mismatch", "different"]
            
            found_keywords = [kw for kw in conflict_keywords if kw in error_text]
            
            assert len(found_keywords) > 0, f"Error should mention conflict. Found keywords: {found_keywords}"
            
            print(f"   ‚úÖ Error message is informative (contains: {found_keywords})")
            
            if isinstance(error_data, dict):
                if "detail" in error_data:
                    print(f"   üìã Error detail: {error_data['detail']}")
                if "error" in error_data:
                    print(f"   üìã Error message: {error_data['error']}")
            
        except json.JSONDecodeError:
            print(f"   üìã Non-JSON error response: {response2.text}")
            error_text = response2.text.lower()
            assert any(kw in error_text for kw in ["conflict", "idempotency", "duplicate"]), "Error text should mention conflict"
        
        print(f"\nüóÑÔ∏è  STEP 4: Verifying no database changes...")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", (lead_data_1['source'],))
        leads_after_second = cursor.fetchone()[0]
        
        cursor.execute("SELECT * FROM leads WHERE id = ?", (lead1_id,))
        db_lead_after_conflict = cursor.fetchone()
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE email = ?", (lead_data_2['email'],))
        conflicting_leads = cursor.fetchone()[0]
        
        print(f"   üìä Leads after second request: {leads_after_second}")
        print(f"   üìä Original lead after conflict: {db_lead_after_conflict}")
        print(f"   üìä Leads with conflicting email: {conflicting_leads}")
        
        assert leads_after_second == leads_after_first, f"No new leads should be created: {leads_after_second} vs {leads_after_first}"
        assert db_lead_original == db_lead_after_conflict, "Original lead should not be modified"
        assert conflicting_leads == 0, f"No leads with conflicting email should exist: {conflicting_leads}"
        
        print(f"   ‚úÖ No database changes detected")
        print(f"   ‚úÖ Original lead preserved")
        print(f"   ‚úÖ No conflicting data created")
        
        print(f"\nüîÑ STEP 5: Verifying original request still works...")
        
        response3 = intake_client.post(
            endpoint,
            json=lead_data_1,  
            headers={"Idempotency-Key": idempotency_key}  
        )
        
        print(f"   üìã Third response (original data): {response3.status_code}")
        
        assert response3.status_code == 200, f"Original request should still work: {response3.status_code}"
        
        lead3_data = response3.json()
        
        assert lead3_data == lead1_data, "Third response should be identical to first"
        
        print(f"   ‚úÖ Original idempotent request still works")
        print(f"   üìã Third response ID: {lead3_data['id']} (same as first)")
        
        print(f"\nüìä STEP 6: Response time analysis...")
        
        response_time_1 = end_time_1 - start_time_1
        response_time_2 = end_time_2 - start_time_2
        
        print(f"   üìä First request (success): {response_time_1:.3f}s")
        print(f"   üìä Second request (conflict): {response_time_2:.3f}s")
        
        if response_time_2 < response_time_1:
            print(f"   ‚úÖ Conflict detected quickly")
        else:
            print(f"   ‚ÑπÔ∏è  Similar response times")
        
        print(f"\nüéâ IDEMPOTENCY CONFLICT TEST PASSED!")
        print(f"   ‚úÖ Conflict correctly detected ({response2.status_code})")
        print(f"   ‚úÖ Informative error message")
        print(f"   ‚úÖ No database corruption")
        print(f"   ‚úÖ Original request still works")
        
        return {
            "original_lead_id": lead1_id,
            "conflict_status": response2.status_code,
            "error_response": response2.json() if response2.status_code != 500 else response2.text,
            "response_times": {
                "original": response_time_1,
                "conflict": response_time_2
            }
        }

    def test_idempotency_various_conflicts(self, intake_client, db_connection):
        """
        –¢–µ—Å—Ç —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        """
        print("\nüéØ TEST: Various Idempotency Conflicts")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        cursor = db_connection.cursor()
        
        print("\n   üîç Conflict 1: Email change only")
        
        key1 = f"email-conflict-{int(time.time())}"
        
        original_data = {
            "email": "original@example.com",
            "name": "Same User",
            "note": "Same note content",
            "source": "various_conflicts_test"
        }
        
        modified_email_data = {
            "email": "modified@example.com",  
            "name": "Same User",
            "note": "Same note content",
            "source": "various_conflicts_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=original_data,
            headers={"Idempotency-Key": key1}
        )
        
        assert response1.status_code in [200, 201], "First request should succeed"
        
        response2 = intake_client.post(
            endpoint,
            json=modified_email_data,
            headers={"Idempotency-Key": key1}
        )
        
        assert response2.status_code in [409, 422], f"Email conflict should fail: {response2.status_code}"
        print(f"      ‚úÖ Email conflict detected: {response2.status_code}")
        
        print("\n   üîç Conflict 2: Note change only")
        
        key2 = f"note-conflict-{int(time.time())}"
        
        original_note_data = {
            "email": "note-test@example.com",
            "name": "Note User",
            "note": "Original note content",
            "source": "various_conflicts_test"
        }
        
        modified_note_data = {
            "email": "note-test@example.com",
            "name": "Note User",
            "note": "Modified note content",
            "source": "various_conflicts_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=original_note_data,
            headers={"Idempotency-Key": key2}
        )
        
        assert response1.status_code in [200, 201], "First note request should succeed"
        
        response2 = intake_client.post(
            endpoint,
            json=modified_note_data,
            headers={"Idempotency-Key": key2}
        )
        
        assert response2.status_code in [409, 422], f"Note conflict should fail: {response2.status_code}"
        print(f"      ‚úÖ Note conflict detected: {response2.status_code}")
        
        print("\n   üîç Conflict 3: Field addition")
        
        key3 = f"field-addition-{int(time.time())}"
        
        minimal_data = {
            "email": "minimal@example.com",
            "note": "Minimal data",
            "source": "various_conflicts_test"
        }
        
        extended_data = {
            "email": "minimal@example.com",
            "phone": "+1234567890",  
            "name": "Added Name",    
            "note": "Minimal data",
            "source": "various_conflicts_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=minimal_data,
            headers={"Idempotency-Key": key3}
        )
        
        assert response1.status_code in [200, 201], "Minimal request should succeed"
        
        response2 = intake_client.post(
            endpoint,
            json=extended_data,
            headers={"Idempotency-Key": key3}
        )
        
        assert response2.status_code in [409, 422], f"Field addition conflict should fail: {response2.status_code}"
        print(f"      ‚úÖ Field addition conflict detected: {response2.status_code}")
        
        print("\n   üîç Conflict 4: Field removal")
        
        key4 = f"field-removal-{int(time.time())}"
        
        full_data = {
            "email": "full@example.com",
            "phone": "+1234567890",
            "name": "Full User",
            "note": "Full data",
            "source": "various_conflicts_test"
        }
        
        reduced_data = {
            "email": "full@example.com",
            "note": "Full data",
            "source": "various_conflicts_test"
        }
        
        response1 = intake_client.post(
            endpoint,
            json=full_data,
            headers={"Idempotency-Key": key4}
        )
        
        assert response1.status_code in [200, 201], "Full request should succeed"
        
        response2 = intake_client.post(
            endpoint,
            json=reduced_data,
            headers={"Idempotency-Key": key4}
        )
        
        assert response2.status_code in [409, 422], f"Field removal conflict should fail: {response2.status_code}"
        print(f"      ‚úÖ Field removal conflict detected: {response2.status_code}")
        
        cursor.execute("SELECT COUNT(*) FROM leads WHERE source = ?", ("various_conflicts_test",))
        total_leads = cursor.fetchone()[0]
        
        assert total_leads == 4, f"Should have 4 leads from first requests, got {total_leads}"
        
        print(f"\n   üìä Database verification: {total_leads} leads created (correct)")
        print(f"üéâ VARIOUS CONFLICTS TEST PASSED!")

    def test_idempotency_conflict_edge_cases(self, intake_client):
        """
        –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        """
        print("\nüéØ TEST: Idempotency Conflict Edge Cases")
        
        endpoint = self._find_post_endpoint(intake_client)
        if not endpoint:
            pytest.skip("No working POST endpoint found")
        
        print("\n   üîç Edge Case 1: Very similar data")
        
        key1 = f"similar-{int(time.time())}"
        
        data1 = {
            "email": "similar@example.com",
            "note": "This is a test message",
            "source": "edge_conflict_test"
        }
        
        data2 = {
            "email": "similar@example.com",
            "note": "This is a test message.", 
            "source": "edge_conflict_test"
        }
        
        response1 = intake_client.post(endpoint, json=data1, headers={"Idempotency-Key": key1})
        response2 = intake_client.post(endpoint, json=data2, headers={"Idempotency-Key": key1})
        
        assert response1.status_code in [200, 201], "First similar request should succeed"
        assert response2.status_code in [409, 422], "Minor difference should cause conflict"
        
        print(f"      ‚úÖ Minor text difference detected")
        
        print("\n   üîç Edge Case 2: Different field order")
        
        key2 = f"order-{int(time.time())}"
        
        data_order1 = {
            "email": "order@example.com",
            "name": "Order User",
            "note": "Field order test",
            "source": "edge_conflict_test"
        }
        
        data_order2 = {
            "note": "Field order test",
            "source": "edge_conflict_test",
            "email": "order@example.com",
            "name": "Order User"
        }
        
        response1 = intake_client.post(endpoint, json=data_order1, headers={"Idempotency-Key": key2})
        response2 = intake_client.post(endpoint, json=data_order2, headers={"Idempotency-Key": key2})
        
        assert response1.status_code in [200, 201], "First order request should succeed"
        assert response2.status_code == 200, "Same content in different order should be idempotent"
        
        print(f"      ‚úÖ Field order doesn't matter for idempotency")
        
        print("\n   üîç Edge Case 3: Null vs missing fields")
        
        key3 = f"null-{int(time.time())}"
        
        data_missing = {
            "email": "null-test@example.com",
            "note": "Null test",
            "source": "edge_conflict_test"
        }
        
        data_null = {
            "email": "null-test@example.com",
            "phone": None,  
            "note": "Null test",
            "source": "edge_conflict_test"
        }
        
        response1 = intake_client.post(endpoint, json=data_missing, headers={"Idempotency-Key": key3})
        response2 = intake_client.post(endpoint, json=data_null, headers={"Idempotency-Key": key3})
        
        assert response1.status_code in [200, 201], "Missing field request should succeed"
        
        if response2.status_code == 200:
            print(f"      ‚úÖ Null treated as missing (idempotent)")
        elif response2.status_code in [409, 422]:
            print(f"      ‚úÖ Null vs missing treated as conflict")
        else:
            print(f"      ‚ö†Ô∏è  Unexpected status: {response2.status_code}")
        
        print(f"üéâ CONFLICT EDGE CASES TEST PASSED!")

    def test_cleanup_idempotency_test_data(self, db_connection):
        """–û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏"""
        print("\nüßπ Cleaning up idempotency test data...")
        
        cursor = db_connection.cursor()
        
        test_emails = [
            "idempotency-test@example.com",
            "multiple-idempotency@example.com",
            "edge-case-1@example.com",
            "edge-case-2@example.com",
            "edge-case-3@example.com",
            "conflict-original@example.com",
            "conflict-different@example.com",
            "original@example.com",
            "modified@example.com",
            "note-test@example.com",
            "minimal@example.com",
            "full@example.com",
            "similar@example.com",
            "order@example.com",
            "null-test@example.com"
        ]
        
        test_sources = [
            "idempotency_detailed_test",
            "multiple_idempotency_test",
            "edge_case_test",
            "conflict_test",
            "various_conflicts_test",
            "edge_conflict_test"
        ]
        
        for email in test_emails:
            cursor.execute("DELETE FROM leads WHERE email = ?", (email,))
        
        for source in test_sources:
            cursor.execute("DELETE FROM leads WHERE source = ?", (source,))
        
        db_connection.commit()
        print("‚úÖ Idempotency test data cleaned up")

    def test_cleanup_idempotency_test_data(self, db_connection):
        """–û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏"""
        print("\nüßπ Cleaning up idempotency test data...")
        
        cursor = db_connection.cursor()
        
        test_emails = [
            "idempotency-test@example.com",
            "multiple-idempotency@example.com",
            "edge-case-1@example.com",
            "edge-case-2@example.com",
            "edge-case-3@example.com"
        ]
        
        test_sources = [
            "idempotency_detailed_test",
            "multiple_idempotency_test",
            "edge_case_test"
        ]
        
        for email in test_emails:
            cursor.execute("DELETE FROM leads WHERE email = ?", (email,))
        
        for source in test_sources:
            cursor.execute("DELETE FROM leads WHERE source = ?", (source,))
        
        db_connection.commit()
        print("‚úÖ Idempotency test data cleaned up")